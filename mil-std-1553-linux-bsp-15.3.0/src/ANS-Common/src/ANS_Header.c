/* SPDX-FileCopyrightText: 2013-2021 AIM GmbH <info@aim-online.com> */
/* SPDX-License-Identifier: MIT  */

/*! \file ANS_Header.c
 *
 * This file contains the implementations of functions for reading an ANS Header
 *
 *
 ******************************************************************************/
#define MODULENAME "ANS_Header"

/* Includes *******************************************************************/

#include <stdlib.h>

#include "ANS_Header.h"
#include "ANS_Log.h"
#include "Ai_Socket.h"
#include "Ai_cdef.h"
#include "Ai_Validate.h"

/* Constants ******************************************************************/

/* Macros *********************************************************************/

/* Type definitions ***********************************************************/

/* Prototypes *****************************************************************/

/* Variables ******************************************************************/

/* Functions ******************************************************************/

/**************************************************************************//**
 * This function reads an ANS header from the open channel.
 *****************************************************************************/
extern	AnsStatus	ANS_Header_read2Buffer (
    struct AnsConnection* connection,   /*!< [in] connection to read from */
    unsigned long const timeOutMs,  /*!< [in] read timeout [ms] or      */
                                    /*!< NTSOCKET_TIMEOUT_INFINITE      */
    MemChunk		    *pRxBuffer)   /*!< [out] RX Buffer read on success   */
{
    AnsStatus              rc;
    ANS_Header const       *pHeader;
    AiBoolean				boolRc = AiFalse;

    VALIDATE_PTR(connection, AnsStatus_Error);
    VALIDATE_PTR(pRxBuffer, AnsStatus_Error);

    boolRc = MemChunk_reallocate(pRxBuffer, sizeof(ANS_Header));
    if ( AiFalse == boolRc )
    {
        ANSLogError(MODULENAME ": ERROR: Out of Memory!");
        return AnsStatus_OutOfMemory;    /** \return AnsStatus_OutOfMemory */
    }

    rc = AnsConnection_receive(connection, (char *) pRxBuffer->pMemory, sizeof(ANS_Header), timeOutMs);
    if(rc != AnsStatus_OK)
    {
        ANSLogDebug("Failed to receive ANS header");
        return rc;
    }

    /*
     * Perform a first plausibility check on the header.
     */
    pHeader = (ANS_Header *) pRxBuffer->pMemory;
    if ( pHeader->fragmentIndex != 0 )
    {
        ANSLogError(MODULENAME ": ERROR: unexpected fragment index (not 0): %d\n", (int) pHeader->fragmentIndex);
        rc = AnsStatus_InvalidHeader;
    }
    else if ( pHeader->fragmentPayloadSize > pHeader->transactionSize )
    {
        ANSLogError(MODULENAME ": ERROR: fragmentPayloadSize(%d) > transactionSize(%d)\n", (int) pHeader->fragmentPayloadSize,
                    (int) pHeader->transactionSize);
        rc = AnsStatus_InvalidHeader;
    }
    else
    {
        rc = AnsStatus_OK;             /** \return AnsStatus_OK       */
    }
    
    return rc;
}

/**************************************************************************//**
 * This function creates an ANS_Header structure using the specified
 * memory chunk.
 *****************************************************************************/
extern AnsStatus ANS_Header_create (
    AiUInt32 const transactionId,   /*!< [in] ID of the transaction         */
    AiUInt32 const transactionSize, /*!< [in] Transaction size in bytes      */
    AiUInt32 const fragmentIndex,   /*!< [in] Fragment index (reserved for future use) */
    AiUInt32 const fragmentPayloadSize, 
                                    /*!< [in] Fragment payload size (reserved for future use) */
    AiUInt32 const clientId,        /*!< [in] Unique Client ID (generated by server) */
    MemChunk      *pBuffer)         /*!< [in,out] Header buffer             */
{
    AiUInt32				nTotalBytes;
    AiBoolean				status = AiFalse;
    ANS_Header				*pHeader;

    VALIDATE_PTR(pBuffer, AnsStatus_Error);    /** \return AnsStatus_Error */

    /* allocate memory for the whole response Frame */
    nTotalBytes = sizeof(ANS_Header) + transactionSize;
    status = MemChunk_reallocate(pBuffer, nTotalBytes);

    if ( AiFalse == status )
    {
        ANSLogError(MODULENAME ": ERROR : Header create, Out of Memory!");
        return AnsStatus_OutOfMemory;  /** \return AnsStatus_OutOfMemory */
    }

    pHeader = (ANS_Header *)pBuffer->pMemory;

    /* Fill Header */
    pHeader->transactionId		 = transactionId;
    pHeader->transactionSize 	 = transactionSize;
    pHeader->fragmentIndex 		 = fragmentIndex;
    pHeader->fragmentPayloadSize = fragmentPayloadSize;
    pHeader->clientId			 = clientId;

    return AnsStatus_OK;	            /** \return AnsStatus_OK           */
}
